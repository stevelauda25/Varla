{"history":[{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"video","usesPingPong":false,"texture":{"sampler":"uThumbnail","src":"https://firebasestorage.googleapis.com/v0/b/unicorn-studio.appspot.com/o/2oXvAYzHk3NHgfOPUvGPg15BRBE2%2Fu3474752699_httpss.mj.runnNpK9SXgc38_locked-off_static_wide_s_e65cacbe-4ff8-4a10-926e-23c8d7ef11af_1%20(1)_%40thumbnail.jpg?alt=media&token=1089df5a-9475-4639-871e-8a9228986b80"},"src":"https://assets.unicorn.studio/videos/2oXvAYzHk3NHgfOPUvGPg15BRBE2/u3474752699_httpss.mj.runnNpK9SXgc38_locked-off_static_wide_s_e65cacbe-4ff8-4a10-926e-23c8d7ef11af_1%20(1).mp4","playbackRate":1,"loop":true,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":true,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision mediump float;in vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uThumbnail;\nuniform sampler2D uVideoTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src;\n}out vec4 fragColor;const float PI = 3.14159265359;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}vec4 applyAdjustments(vec4 color) {color.rgb = clamp(color.rgb, 0.0, 1.0);\nreturn color;\n}void main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);ivec2 videoTexSize = textureSize(uVideoTexture, 0);\nbool videoReady = videoTexSize.x > 16 && videoTexSize.y > 16;\nivec2 texSize = videoReady ? videoTexSize : textureSize(uThumbnail, 0);\nfloat texWidth = float(texSize.x);\nfloat texHeight = float(texSize.y);\nfloat videoAspect = texWidth / max(texHeight, 0.0001);float screenAspect = (uResolution.x / uResolution.y);\nvec2 centeredUV = uv;if (1 == 1) {\nvec2 centered = uv - 0.5;\nif (screenAspect < videoAspect) {\ncenteredUV = vec2( (uv.x - 0.5) * (screenAspect / videoAspect), uv.y - 0.5) + 0.5;\n} else {\ncenteredUV = vec2( uv.x - 0.5, (uv.y - 0.5) * (videoAspect / screenAspect) ) + 0.5;\n}\ncenteredUV += (bg.rg * 2.0 - 1.0) * 0.0000;\n} else {\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\ncenteredUV = centeredUV - pos;\ncenteredUV.x *= screenAspect;\ncenteredUV = (centeredUV) / 0.8000;\ncenteredUV = centeredUV * rot(0.0000 * 2.0 * PI);\ncenteredUV.x /= videoAspect;\ncenteredUV += 0.5;\ncenteredUV += (bg.rg * 2.0 - 1.0) * 0.0000;\nif(centeredUV.x < 0.0 || centeredUV.x > 1.0 || centeredUV.y < 0.0 || centeredUV.y > 1.0) {\nfragColor = bg;\nreturn;\n}\n}\nvec4 color;\nif (videoReady) {\ncolor = texture(uVideoTexture, centeredUV);\n} else {\ncolor = texture(uThumbnail, centeredUV);\n}\ncolor.rgb = color.rgb / max(color.a, 0.0001);\ncolor = applyAdjustments(color);if(0 > 0) {\ncolor.rgb = blend(0, bg.rgb, color.rgb);\n}float videoAlpha = color.a * 1.0000;\ncolor.rgb = mix(bg.rgb, color.rgb, videoAlpha);\ncolor.a = bg.a + videoAlpha * (1.0 - bg.a);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uThumbnail"}},"id":"video"},{"breakpoints":[],"aspectRatio":1.6,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":0,"mask":1,"maskDepthLayer":1,"layerType":"shape","width":1338,"widthMode":1,"height":899,"heightMode":1,"left":0.035416666666666666,"top":0.0011111111111111111,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0.0196078431372549, 0.10980392156862745);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}uniform vec2 uArtboardResolution;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.0, 0.0);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);halfSize = uArtboardResolution * 0.5;\np = canvasPosPx - halfSize;\nreturn sdBox(p, halfSize);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 1338.0000;\nfloat absHeight = 899.0000;if (1 == 2) {\nabsWidth = absHeight * 1.6000;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.6000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.0354, 0.0011) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = canvasPosPx;\nvec2 localSize;\nlocalSize = uArtboardResolution;\nvec2 centerPx;\ncenterPx = uArtboardResolution * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getMaskOutput(vec4 color, vec4 background) {background *= color.a;\ncolor.rgb = background.rgb;\ncolor.rgb = 0.0000 > 0.0 ? mix(vec3(0, 0, 0), color.rgb / max(color.a, 0.0001), color.a) : color.rgb;\ncolor.a = min(1.0, color.a + 0.0000);return color;\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getMaskOutput(color, background);\n}vec4 getCompositeOutput(vec2 uv) {\nvec4 background = vec4(0.0);background = texture(uBgTexture, vTextureCoord);vec4 color = sampleShape(uv);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getCompositeOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.6}}},"id":"shape"},{"breakpoints":[],"aspectRatio":1.5,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":8,"mask":0,"maskDepthLayer":1,"layerType":"shape","width":1433,"widthMode":1,"height":961,"heightMode":1,"left":0.5003472222222223,"top":0.4984375,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0.0196078431372549, 0.10980392156862745);\ncase 1: return vec3(0, 0, 0);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}uniform vec2 uArtboardResolution;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;vec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn src + dst;\n}const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.5);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);halfSize = uArtboardResolution * 0.5;\np = canvasPosPx - halfSize;\nreturn sdBox(p, halfSize);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 1433.0000;\nfloat absHeight = 961.0000;if (1 == 2) {\nabsWidth = absHeight * 1.5000;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.5000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.5003, 0.4984) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 0.0000), mix(aa, 150., 0.0000), dist);\nvec2 localPos;\nlocalPos = canvasPosPx;\nvec2 localSize;\nlocalSize = uArtboardResolution;\nvec2 centerPx;\ncenterPx = uArtboardResolution * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nvec3 unpremultColor = color.rgb / max(color.a, 0.0001);\nvec3 blendedColor = blend(1, unpremultColor, background.rgb);\ncolor = vec4(blendedColor, 1.0) * (color.a * 1.0000);\ncolor = color + background * (1.0 - color.a);\nreturn color;\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 getCompositeOutput(vec2 uv) {\nvec4 background = vec4(0.0);background = texture(uBgTexture, vTextureCoord);vec4 color = sampleShape(uv);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getCompositeOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.5}}},"id":"shape1"},{"breakpoints":[],"aspectRatio":1.5,"userDownsample":1,"states":{"appear":[],"scroll":[],"hover":[],"mousemove":[]},"effects":[],"anchorPoint":1,"mask":0,"maskDepthLayer":1,"layerType":"shape","width":1440,"widthMode":1,"height":311,"heightMode":1,"left":0.5,"top":0.8223958333333333,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec2 vTextureCoord;\nin vec3 vVertexPosition;vec3 getColor(int index) {\nswitch(index) {\ncase 0: return vec3(0, 0.0196078431372549, 0.10980392156862745);\ncase 1: return vec3(0, 0.0196078431372549, 0.10980392156862745);\ncase 2: return vec3(0, 0, 0);\ncase 3: return vec3(0, 0, 0);\ncase 4: return vec3(0, 0, 0);\ncase 5: return vec3(0, 0, 0);\ncase 6: return vec3(0, 0, 0);\ncase 7: return vec3(0, 0, 0);\ncase 8: return vec3(0, 0, 0);\ncase 9: return vec3(0, 0, 0);\ncase 10: return vec3(0, 0, 0);\ncase 11: return vec3(0, 0, 0);\ncase 12: return vec3(0, 0, 0);\ncase 13: return vec3(0, 0, 0);\ncase 14: return vec3(0, 0, 0);\ncase 15: return vec3(0, 0, 0);\ndefault: return vec3(0.0);\n}\n}float getStop(int index) {\nswitch(index) {\ncase 0: return 0.0000;\ncase 1: return 1.0000;\ncase 2: return 2.0000;\ncase 3: return 3.0000;\ncase 4: return 4.0000;\ncase 5: return 5.0000;\ncase 6: return 6.0000;\ncase 7: return 7.0000;\ncase 8: return 8.0000;\ncase 9: return 9.0000;\ncase 10: return 10.0000;\ncase 11: return 11.0000;\ncase 12: return 12.0000;\ncase 13: return 13.0000;\ncase 14: return 14.0000;\ncase 15: return 15.0000;\ndefault: return 0.0;\n}\n}uniform vec2 uArtboardResolution;uniform vec2 uMousePos;\nuniform sampler2D uBgTexture;const float TAU = 6.28318530718;\nconst float PI = 3.14159265;out vec4 fragColor;vec2 rotate2D(vec2 p, float angle) {\nfloat s = sin(angle);\nfloat c = cos(angle);\nreturn vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n}vec2 getAnchorOffsets() {\nreturn vec2(0.5, 0.0);\n}vec3 linear_from_srgb(vec3 rgb) {\nreturn pow(max(rgb, vec3(0.0)), vec3(2.2));\n}vec3 srgb_from_linear(vec3 lin) {\nreturn pow(max(lin, vec3(0.0)), vec3(1.0/2.2));\n}vec3 safeCbrt(vec3 v) {\nreturn sign(v) * pow(abs(v), vec3(1.0/3.0));\n}vec3 oklab_mix(vec3 lin1, vec3 lin2, float a) {\nconst mat3 kCONEtoLMS = mat3(\n0.4121656120, 0.2118591070, 0.0883097947,\n0.5362752080, 0.6807189584, 0.2818474174,\n0.0514575653, 0.1074065790, 0.6302613616);\nconst mat3 kLMStoCONE = mat3(\n4.0767245293, -1.2681437731, -0.0041119885,\n-3.3072168827, 2.6093323231, -0.7034763098,\n0.2307590544, -0.3411344290, 1.7068625689);vec3 lms1 = safeCbrt(kCONEtoLMS * lin1);\nvec3 lms2 = safeCbrt(kCONEtoLMS * lin2);\nvec3 lms = mix(lms1, lms2, a);\nlms *= 1.0 + 0.025 * a * (1.0 - a);\nreturn kLMStoCONE * (lms * lms * lms);\n}vec3 getGradientColor(float position) {\nposition = clamp(position, 0.0, 1.0);\nif (2 <= 1) return getColor(0);for (int i = 0; i < 15; i++) {\nif (i >= 2 - 1) break;\nfloat stopA = getStop(i);\nfloat stopB = getStop(i + 1);\nif (position <= stopB || i == 2 - 2) {\nfloat denom = max(stopB - stopA, 0.00001);\nfloat t = clamp((position - stopA) / denom, 0.0, 1.0);\nvec3 linA = linear_from_srgb(getColor(i));\nvec3 linB = linear_from_srgb(getColor(i + 1));\nvec3 mixed = oklab_mix(linA, linB, t);\nreturn srgb_from_linear(mixed);\n}\n}\nreturn getColor(min(2 - 1, 15));\n}vec3 getLinearGradientColor(vec2 p, vec2 halfSize, float angle) {\nvec2 d = vec2(cos(angle) * halfSize.x, sin(angle) * halfSize.y);\nfloat dd = max(dot(d, d), 0.00001);\nfloat pos = 0.5 + 0.5 * (dot(p, d) / dd);\nreturn getGradientColor(pos);\n}vec3 getFillColor(vec2 localPos, vec2 elementSize, float signedDist, float maxInset) {\nvec2 halfSize = elementSize * 0.5;\nvec2 p = localPos - halfSize;float angle = 0.7486 * TAU;\nreturn getLinearGradientColor(p, halfSize, angle);return getColor(0);\n}float sdBox(vec2 p, vec2 b) {\nvec2 d = abs(p) - b;\nreturn length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);\n}float sdShape(vec2 canvasPosPx, vec2 elementPosPx, vec2 elementSizePx, float rotationTurns) {\nvec2 p = vec2(0.0);\nvec2 halfSize = vec2(0.0);elementSizePx = abs(elementSizePx);vec2 centerPx = elementPosPx + elementSizePx * 0.5;\nvec2 rel = canvasPosPx - centerPx;\nvec2 local = rotate2D(rel, -rotationTurns * TAU) + elementSizePx * 0.5;\np = local - elementSizePx * 0.5;\nhalfSize = elementSizePx * 0.5;\nreturn sdBox(p, halfSize);\n}vec4 sampleShape(vec2 canvasUV) {\nvec2 canvasPosPx = vec2(canvasUV.x * uArtboardResolution.x, (1.0 - canvasUV.y) * uArtboardResolution.y);float absWidth = 1440.0000;\nfloat absHeight = 311.0000;if (1 == 2) {\nabsWidth = absHeight * 1.5000;\n} else if (1 == 2) {\nabsHeight = absWidth / 1.5000;\n}vec2 elementSizePx = vec2(absWidth, absHeight);\nvec2 elementPosPx = vec2(0.5000, 0.8224) * uArtboardResolution - getAnchorOffsets() * elementSizePx;float dist = sdShape(canvasPosPx, elementPosPx, elementSizePx, 0.0000);\nfloat aa = max(length(vec2(dFdx(dist), dFdy(dist))), 0.75);float fillAlpha = 1.0 - smoothstep(mix(0.0, -150., 1.0000), mix(aa, 150., 1.0000), dist);\nvec2 localPos;\nlocalPos = rotate2D(canvasPosPx - (elementPosPx + elementSizePx * 0.5), 0.0000 * -TAU) + elementSizePx * 0.5;\nvec2 localSize;\nlocalSize = elementSizePx;\nvec2 centerPx;\ncenterPx = elementPosPx + elementSizePx * 0.5;\nfloat centerDist = sdShape(centerPx, elementPosPx, elementSizePx, 0.0000);\nfloat maxInset = max(-centerDist, 0.00001);vec3 fillRgb = getFillColor(localPos, localSize, dist, maxInset);\nfloat finalFillAlpha = fillAlpha * 1.0000;\nvec4 fill = vec4(fillRgb * finalFillAlpha, finalFillAlpha);float strokeAlpha = 0.0;\nvec4 stroke = vec4(vec3(0, 0, 0) * strokeAlpha, strokeAlpha);\nvec4 col = stroke + fill * (1.0 - stroke.a);\nreturn col;\n}vec4 getNormalOutput(vec4 color, vec4 background) {\nreturn mix(background, color + background * (1.0 - color.a), 1.0000);\n}vec4 getOutputByMode(vec4 color, vec4 background) {\nreturn getNormalOutput(color, background);\n}vec4 getCompositeOutput(vec2 uv) {\nvec4 background = vec4(0.0);background = texture(uBgTexture, vTextureCoord);vec4 color = sampleShape(uv);return getOutputByMode(color, background);\n}void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = (uMousePos - 0.5) * 0.0000;uv -= pos;fragColor = getCompositeOutput(uv);\n}"],"compiledVertexShaders":["#version 300 es\nprecision highp float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform vec2 uMousePos;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\nfloat angleX = uMousePos.y * 0.5 - 0.25;\nfloat angleY = (1.-uMousePos.x) * 0.5 - 0.25;mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n0.0, cos(angleX), -sin(angleX), 0.0,\n0.0, sin(angleX), cos(angleX), 0.0,\n0.0, 0.0, 0.0, 1.0);\nmat4 rotateY = mat4(cos(angleY), 0.0, sin(angleY), 0.0,\n0.0, 1.0, 0.0, 0.0,\n-sin(angleY), 0.0, cos(angleY), 0.0,\n0.0, 0.0, 0.0, 1.0);mat4 rotationMatrix = rotateX * rotateY;\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvVertexPosition = (rotationMatrix * vec4(aVertexPosition, 1.0)).xyz;\nvTextureCoord = (vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"uniforms":{"artboardResolution":{"name":"uArtboardResolution","type":"2f","value":{"type":"Vec2","_x":1440,"_y":900}},"aspectRatio":{"name":"uAspectRatio","type":"1f","value":1.5}}},"id":"shape2"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn 1. - (1. - src) * (1. - dst);\n}out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.3500, 1.0 - 0.3500);\nfloat halfRadius = 0.4200 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5008849557522124, 0.5610619469026549);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0000 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;vec3 blended = blend(4, vec3(0, 0.0196078431372549, 0.10980392156862745), bg.rgb);\nfinalColor = mix(bg.rgb, blended, falloff * 1.0000);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"vignette"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"glyphDither","usesPingPong":false,"texture":{"src":"https://assets.unicorn.studio/media/glyphs/squares.png","sampler":"uSprite"},"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;in vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform sampler2D uSprite;\nuniform sampler2D uCustomTexture;uniform vec2 uMousePos;\nuniform vec2 uResolution;out vec4 fragColor;void main() {\nvec2 uv = vTextureCoord;\nvec2 pos = vec2(0.5, 0.5) + mix(vec2(0), (uMousePos-0.5), 0.0000);\nfloat aspectRatio = uResolution.x / uResolution.y;\nfloat aspectCorrection = mix(aspectRatio, 1./aspectRatio, 0.5);float gridSize = mix(0.05, 0.005, 0.9500);float baseGrid = 1.0 / gridSize;\nvec2 cellSize = vec2(1.0/(baseGrid * aspectRatio), 1.0/baseGrid) * aspectCorrection;\nvec2 offsetUv = uv - pos;\nvec2 cell = floor(offsetUv / cellSize);\nvec2 cellCenter = (cell + 0.5) * cellSize;\nvec2 pixelatedCoord = cellCenter + pos;\nvec4 bg = texture(uTexture, vTextureCoord);\nvec4 color = texture(uTexture, pixelatedCoord);float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));\nluminance = mix(luminance, 1.0 - luminance, float(0));\nfloat gamma = pow(mix(0.2, 2.2, 1.0000), 2.2);ivec2 customTextureSize = textureSize(uCustomTexture, 0);\nivec2 spriteTextureSize = textureSize(uSprite, 0);\nfloat selectedWidth = mix(float(spriteTextureSize.x), float(customTextureSize.x), float(0 == 6));\nfloat GLYPH_HEIGHT = mix(float(spriteTextureSize.y), float(customTextureSize.y), float(0 == 6));\nfloat scaleFactor = gridSize / GLYPH_HEIGHT;\nfloat numSprites = max(1.0, selectedWidth / GLYPH_HEIGHT);\nfloat numGlyphRows = 1.0;float spriteIndex = clamp(floor(luminance * numSprites), 0.0, numSprites - 1.0);\nfloat spriteIndexWithGamma = clamp(floor(luminance * numSprites * gamma), 0.0, numSprites - 1.0);\nfloat phaseOffset = floor(0.0000 * numSprites + 0.5);\nspriteIndexWithGamma = mod(spriteIndexWithGamma + phaseOffset, numSprites);\nfloat glyphIndex = 0.0;float normalizedSpriteSizeX = 1.0 / numSprites;\nfloat normalizedSpriteSizeY = 1.0 / numGlyphRows;float spriteX = (spriteIndexWithGamma * normalizedSpriteSizeX);vec2 spriteSheetUV = vec2(spriteX, glyphIndex / numGlyphRows);vec2 spriteSize = vec2(GLYPH_HEIGHT / aspectRatio, GLYPH_HEIGHT) * scaleFactor * aspectCorrection;\nvec2 localOffset = mod(uv - pos, spriteSize) / spriteSize;float inset = 0.5 / GLYPH_HEIGHT;\nlocalOffset = clamp(localOffset, inset, 1.0 - inset);spriteSheetUV += vec2(localOffset.x * normalizedSpriteSizeX, localOffset.y * normalizedSpriteSizeY);vec4 spriteColor = vec4(0.0);spriteColor = texture(uSprite, spriteSheetUV);\nfloat alpha = smoothstep(0.0, 1.0, spriteColor.r);vec3 cc = (color.rgb - spriteIndex * 0.04) * 1.4;\nvec3 col = cc;vec3 dithered = mix(\nmix(vec3(0.0), vec3(1.0), float(0)),\ncol,\nalpha\n);\ncolor.rgb = mix(bg.rgb, dithered, 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false,"texture":{"src":"","sampler":"uSprite"}},"id":"glyph_dither"},{"breakpoints":[],"visible":true,"aspectRatio":1,"userDownsample":1,"layerType":"effect","type":"vignette","usesPingPong":false,"trackMouse":0,"trackAxes":"xy","mouseMomentum":0,"texture":false,"animating":false,"isMask":0,"compiledFragmentShaders":["#version 300 es\nprecision highp float;\nin vec3 vVertexPosition;\nin vec2 vTextureCoord;\nuniform sampler2D uTexture;\nuniform vec2 uResolution;\nvec3 blend (int blendMode, vec3 src, vec3 dst) {\nreturn vec3((src.x > 0.5) ? max(dst.x, 2.0 * (src.x - 0.5)) : min(dst.x, 2.0 * src.x), (src.x > 0.5) ? max(dst.y, 2.0 * (src.y - 0.5)) : min(dst.y, 2.0 * src.y), (src.z > 0.5) ? max(dst.z, 2.0 * (src.z - 0.5)) : min(dst.z, 2.0 * src.z));\n}out vec4 fragColor;\nmat2 rot(float a) {\nreturn mat2(cos(a),-sin(a),sin(a),cos(a));\n}\nvoid main() {\nvec2 uv = vTextureCoord;\nvec4 bg = texture(uTexture, uv);\nfloat luma = dot(bg.rgb, vec3(0.299, 0.587, 0.114));\nfloat displacement = (luma - 0.5) * 0.0000 * 0.5;\nvec2 aspectRatio = vec2(uResolution.x/uResolution.y, 1.0);\nvec2 skew = vec2(0.3500, 1.0 - 0.3500);\nfloat halfRadius = 0.5520 * 0.5;\nfloat innerEdge = halfRadius - 1.0000 * halfRadius * 0.5;\nfloat outerEdge = halfRadius + 1.0000 * halfRadius * 0.5;\nvec2 pos = vec2(0.5008849557522124, 0.5610619469026549);\nconst float TWO_PI = 6.28318530718;\nvec2 scaledUV = uv * aspectRatio * rot(0.0027 * TWO_PI) * skew;\nvec2 scaledPos = pos * aspectRatio * rot(0.0027 * TWO_PI) * skew;\nfloat radius = distance(scaledUV, scaledPos);\nfloat falloff = smoothstep(innerEdge + displacement, outerEdge + displacement, radius);\nvec3 finalColor;vec3 blended = blend(16, vec3(0, 0.0196078431372549, 0.10980392156862745), bg.rgb);\nfinalColor = mix(bg.rgb, blended, falloff * 1.0000);float alpha = max(bg.a, falloff * 1.0000);\nvec4 color = mix(bg * (1.-falloff), vec4(finalColor * alpha, alpha), 1.0000);\nfragColor = color;}"],"compiledVertexShaders":["#version 300 es\nprecision mediump float;in vec3 aVertexPosition;\nin vec2 aTextureCoord;uniform mat4 uMVMatrix;\nuniform mat4 uPMatrix;\nuniform mat4 uTextureMatrix;out vec2 vTextureCoord;\nout vec3 vVertexPosition;void main() {\ngl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);\nvTextureCoord = (uTextureMatrix * vec4(aTextureCoord, 0.0, 1.0)).xy;\n}"],"data":{"depth":false,"uniforms":{},"isBackground":false},"id":"vignette1"}],"options":{"name":"[Desktop] Latest Hero Section Varla","fps":60,"dpi":1.5,"scale":1,"includeLogo":false,"isProduction":false,"freePlan":false},"version":"2.0.4","id":"31va38XM0eOBqyftUxs5"}
